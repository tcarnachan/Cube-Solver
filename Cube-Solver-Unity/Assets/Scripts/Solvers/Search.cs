using System;
using System.Linq;
using System.Threading;
using System.Collections.Generic;
using System.Collections.Concurrent;
using Cube_Solver.Cubes;

namespace Cube_Solver.Solver
{
    using Face = Cube.Face;
    using Dir = Cube.Dir;

    /// <summary>
    /// A class which searches for the solution of a scrambled cube
    /// </summary>
    public class Search
    {
        private SearchTables st;
        private Symmetries sym;

        // Used to exit the search
        private CancellationToken ct;
        // Thread-safe way to store solutions which have already been found
        public static ConcurrentDictionary<string, byte> solutions;

        private int rot;
        private bool inverse;

        public Search(SearchTables st, CancellationToken ct, Symmetries sym, int rot, bool inverse)
        {
            this.st = st;
            this.ct = ct;
            this.sym = sym;
            this.rot = rot;
            this.inverse = inverse;
        }

        private static int maxDepth;
        private Stack<(CubieCube, int)> path1;
        private Stack<(int cp, int ep, int)> path2;

        // Start the solve
        public void Solve(CubieCube cube)
        {
            // Change the cube if run in parallel, so it doesn't just run the exact same search on multiple threads
            if (inverse)
                cube = cube.InverseCube();
            for (int i = 0; i < rot; i++)
                cube = sym.RotURF(cube);
            // Initialise path1 for ida* traversal
            path1 = new Stack<(CubieCube, int)>();
            path1.Push((cube, -1));
            maxDepth = int.MaxValue;
            // Iterative deepening - run depth first search to a depth of i
            for (int i = 0; i < maxDepth; i++)
                Phase1(i);
        }

        /*
         * Goal: take a scrambled cube into a state where it is solvable using the subset of moves
         * generated by <U, D, R2, L2, F2, B2> (i.e any U/D turns, half turns of the other layers).
         * This is equivalent to bringing the cube into a state where every cubie is oriented, and
         * all the middle slice cubies are in the middle slice layer.
         */
        private void Phase1(int depth)
        {
            // If a solution has been found and cancellation is requested
            if (ct.IsCancellationRequested && solutions.Keys.Count > 0) return;

            CubieCube curr = path1.Peek().Item1;
            // Get an estimate of the moves required to complete phase 1 (guaranteed to never over-estimate)
            int heur = Math.Max(st.coTable[st.idCalc.GetCO(curr)], st.eoTable[st.idCalc.GetEO(curr) * SearchTables.NUM_ESLICE + st.idCalc.GetEslice(curr)]);
            // If there are no available moves left
            if (depth == 0)
            {
                int prevMove = path1.Peek().Item2;
                Face f = (Face)(prevMove / 3);
                Dir d = (Dir)(prevMove % 3);
                // If the subgoal is reached, start phase 2
                if (heur == 0 && (prevMove == -1 || !st.phase2moves.Contains((f, d))))
                    BeginPhase2();
            }
            // If the expected number of moves is within the remaining moves
            else if (heur <= depth)
            {
                int prev = path1.Peek().Item2;
                // For all possible moves (or child nodes)
                foreach (var move in st.phase1moves)
                {
                    // If this doesn't introduce redundant moves
                    if (prev == -1 || ValidMove((Face)(prev / 3), move.Item1))
                    {
                        // Search this node
                        path1.Push(((CubieCube)curr.ApplyMove(move.Item1, move.Item2), (int)move.Item1 * 3 + (int)move.Item2));
                        Phase1(depth - 1);
                        path1.Pop();
                    }
                }
            }
        }

        // After completing phase 1, solve the rest of the cube
        private void BeginPhase2()
        {
            int len = path1.Count;
            var curr = path1.Peek();
            // Initialise path2 for ida* traversal
            path2 = new Stack<(int cp, int ep, int)>();
            path2.Push((st.idCalc.GetCP(curr.Item1), st.idCalc.GetEP(curr.Item1), curr.Item2));
            // Search at increasing depths
            for (int i = 0; i < maxDepth - len - 1; i++)
                Phase2(i);
        }

        /* 
         * Goal: solve the cube only using the moves
         * generated by <U, D, R2, L2, F2, B2>
         */
        private void Phase2(int depth)
        {
            // If a solution has been found and cancellation is requested
            if (ct.IsCancellationRequested && solutions.Keys.Count > 0) return;

            var curr = path2.Peek();
            // Get an estimate of the moves required to solve the cube (guaranteed to never over-estimate)
            int heur = Math.Max(st.cpTable[curr.cp], st.epTable[curr.ep]);
            // If there are no available moves left
            if (depth == 0)
            {
                // If the cube is solved, output the solution
                if (heur == 0)
                    EndPhase2();
            }
            // If the expected number of moves is within the remaining moves
            else if (heur <= depth)
            {
                int prev = path2.Peek().Item3;
                // For all possible moves (or child nodes)
                foreach (var move in st.phase2moves)
                {
                    // If this doesn't introduce redundant moves
                    if (prev == -1 || ValidMove((Face)(prev / 3), move.Item1))
                    {
                        (int cp, int ep) next = (curr.cp, curr.ep);
                        if (move.Item1 == Face.D || move.Item1 == Face.U)
                        {
                            for (int i = 0; i <= (int)move.Item2; i++)
                                next = (st.mtCP[next.cp, move.Item1], st.mtEP[next.ep, move.Item1]);
                        }
                        else
                            next = (st.mtCP[next.cp, move.Item1], st.mtEP[next.ep, move.Item1]);
                        // Search this node
                        path2.Push((next.cp, next.ep, (int)move.Item1 * 3 + (int)move.Item2));
                        Phase2(depth - 1);
                        path2.Pop();
                    }
                }
            }
        }

        // Output the solution
        private void EndPhase2()
        {
            // If this is longer than the previous best solution
            if (path1.Count + path2.Count - 2 >= maxDepth) return;

            // Get phase 1 moves
            var temp1 = new Stack<(CubieCube, int)>(path1);
            temp1.Pop();
            List<(int face, int dir)> moves = new List<(int face, int dir)>();
            while (temp1.Count > 0)
            {
                int m = temp1.Pop().Item2;
                moves.Add((m / 3, m % 3));
            }

            // Get phase 2 moves
            var temp2 = new Stack<(int, int, int)>(path2);
            temp2.Pop();
            while (temp2.Count > 0)
            {
                int m = temp2.Pop().Item3;
                moves.Add((m / 3, m % 3));
            }

            // Handle inverse
            if (inverse)
            {
                moves.Reverse();
                for (int i = 0; i < moves.Count; i++)
                    moves[i] = (moves[i].face, 2 - moves[i].dir);
            }

            // Handle rotations
            for (int i = 0; i < rot; i++)
                moves = MakeTrans(moves);

            // Convert it to a string
            string s = "";
            foreach (var mov in moves)
                s += Cube.FACE_CHARS[mov.face] + new string[] { " ", "2 ", "' " }[mov.dir];

            // If this solution has not already been found
            if (!solutions.ContainsKey(s))
            {
                // Mark this solution as found
                solutions[s] = 0;
                // Output the solution
                st.Output($"{s}({moves.Count})");
                // Update maxDepth since we now have a shorter solution
                maxDepth = moves.Count;
            }
        }

        private Face[] transArr = new Face[] { Face.F, Face.U, Face.R };
        private static Dictionary<Face, Face> rotTrans;

        private List<(int, int)> MakeTrans(List<(int f, int d)> moves)
        {
            if (rotTrans == null)
            {
                rotTrans = new Dictionary<Face, Face>();
                for (int i = 0; i < transArr.Length; i++)
                {
                    rotTrans[transArr[i]] = transArr[(i + 1) % transArr.Length];
                    rotTrans[movePairs[transArr[i]]] = movePairs[rotTrans[transArr[i]]];
                }
            }

            return moves.Select(m => ((int)rotTrans[(Face)m.f], m.d)).ToList();
        }

        /*
         * Turning parallel faces 3 moves in a row introduces redundant moves
         *  e.g. R L R is equivalent to R2 L or L R2
         * To prevent this, parallel moves can only occur in certain orders
         *  e.g. F B is allowed, but B F is not
         */
        private Dictionary<Face, Face> movePairs = new Dictionary<Face, Face>
        {
            { Face.F, Face.B },
            { Face.U, Face.D },
            { Face.R, Face.L }
        };

        /// <summary>
        /// Checks if applying this move could introduce redundant moves
        /// based on the previously applied move
        /// </summary>
        private bool ValidMove(Face prev, Face curr)
        {
            if (prev == curr)
                return false;

            return !(movePairs.ContainsKey(prev) && movePairs[prev] == curr);
        }
    }
}
